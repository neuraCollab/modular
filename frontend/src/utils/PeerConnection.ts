import { socket } from './socket';

const PC_CONFIG: RTCConfiguration = {
  iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
};

type EventCallback = (stream: MediaStream) => void;

class PeerConnection {
  private pc: RTCPeerConnection;
  private mediaDevice: MediaDeviceController | null;
  private eventListeners: Map<string, EventCallback>;

  constructor(private friendID: string) {
    this.pc = new RTCPeerConnection(PC_CONFIG);
    this.mediaDevice = null;
    this.eventListeners = new Map();

    // Setup event handlers
    this.pc.onicecandidate = this.handleIceCandidate;
    this.pc.ontrack = this.handleTrack;
  }

  /**
   * Starts the peer connection by initializing media devices
   * and creating an offer or waiting for an offer.
   */
  public start(isCaller: boolean) {
    this.mediaDevice = new MediaDeviceController();

    this.mediaDevice.on('localStream', (stream) => {
      stream.getTracks().forEach((track) => {
        this.pc.addTrack(track, stream);
      });

      this.emit('localStream', stream);

      if (isCaller) {
        socket.emit('request', { to: this.friendID });
      } else {
        this.createOffer();
      }
    });

    this.mediaDevice.start();
  }

  /**
   * Stops the peer connection and cleans up resources.
   */
  public stop(isStarter: boolean) {
    if (isStarter) {
      socket.emit('end', { to: this.friendID });
    }

    this.mediaDevice?.stop();
    this.pc.close();
    this.eventListeners.clear();
  }

  /**
   * Sets the remote SDP (Session Description Protocol) received from the peer.
   */
  public setRemoteDescription(sdp: RTCSessionDescriptionInit) {
    const description = new RTCSessionDescription(sdp);
    this.pc.setRemoteDescription(description).catch(console.error);
  }

  /**
   * Adds an ICE candidate received from the peer.
   */
  public addIceCandidate(candidate: RTCIceCandidateInit | null) {
    if (candidate) {
      const iceCandidate = new RTCIceCandidate(candidate);
      this.pc.addIceCandidate(iceCandidate).catch(console.error);
    }
  }

  /**
   * Creates an SDP offer and sends it to the peer.
   */
  private createOffer() {
    this.pc
      .createOffer()
      .then((desc) => this.setLocalDescription(desc))
      .catch(console.error);
  }

  /**
   * Creates an SDP answer and sends it to the peer.
   */
  public createAnswer() {
    this.pc
      .createAnswer()
      .then((desc) => this.setLocalDescription(desc))
      .catch(console.error);
  }

  /**
   * Sets the local SDP description and sends it to the peer.
   */
  private setLocalDescription(desc: RTCSessionDescriptionInit) {
    this.pc.setLocalDescription(desc).then(() => {
      socket.emit('call', { to: this.friendID, sdp: desc });
    });
  }

  /**
   * Handles ICE candidates generated by the peer connection.
   */
  private handleIceCandidate = (event: RTCPeerConnectionIceEvent) => {
    if (event.candidate) {
      socket.emit('call', {
        to: this.friendID,
        candidate: event.candidate,
      });
    }
  };

  /**
   * Handles incoming media tracks from the peer.
   */
  private handleTrack = (event: RTCTrackEvent) => {
    const [stream] = event.streams;
    if (stream) {
      this.emit('peerStream', stream);
    }
  };

  /**
   * Registers event listeners for custom events.
   */
  public on(event: string, callback: EventCallback): PeerConnection {
    this.eventListeners.set(event, callback);
    return this;
  }

  /**
   * Emits events to registered listeners.
   */
  private emit(event: string, stream: MediaStream) {
    const callback = this.eventListeners.get(event);
    if (callback) {
      callback(stream);
    }
  }
}

class MediaDeviceController {
  private stream: MediaStream | null = null;
  private eventListeners: Map<string, EventCallback> = new Map();

  public start() {
    navigator.mediaDevices
      .getUserMedia({ video: true, audio: true })
      .then((stream) => {
        this.stream = stream;
        this.emit('localStream', stream);
      })
      .catch(console.error);
  }

  public stop() {
    this.stream?.getTracks().forEach((track) => track.stop());
    this.stream = null;
  }

  public on(event: string, callback: EventCallback) {
    this.eventListeners.set(event, callback);
  }

  private emit(event: string, stream: MediaStream) {
    const callback = this.eventListeners.get(event);
    if (callback) {
      callback(stream);
    }
  }
}

export default PeerConnection;
